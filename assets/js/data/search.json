[ { "title": "重构简述", "url": "/posts/%E9%87%8D%E6%9E%84/", "categories": "设计模式", "tags": "Refactoring", "date": "2021-07-12 14:25:00 +0800", "snippet": "重构定义如果你发现自己需要为程序添加一个特性 而代码结构使你无法很方便地达成目的 那就先重构那个程序 使特性的添加比较容易进行 然后再添加特性重构之前 首先检查自己是否有一套可靠的测试机制 这些测试必须有自我检验能力重构技术就是以微小的步伐修改程序 如果你犯下错误 很容易便可发现它任何一个傻瓜都能写出计算机可以理解的代码 唯有写出人类容易理解的代码 才是优秀的程序员重构(名词) 对软件内部结构的一种调整 目的是在不改变软件可观察行为的前提下 提供其可理解性 降低其修改成本重构(动词) 使用一系列重构手法 在不改变软件可观察行为的前提下 调整其结构重构目的重构的目的是使软件更容易被理解和修..." }, { "title": "Android Studio插件开发记录", "url": "/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/", "categories": "Android Studio", "tags": "Intellij Idea, Android Studio, 插件", "date": "2021-06-18 14:50:00 +0800", "snippet": "基于 IntelliJ IDEA CE (Build版本：202.7660.3 ，对应Android Studio 4.2.1）相关资源 官方社区文档 Github仓库 创建Intellij IDEA插件简介 创建Intellij IDEA插件的高级指南" }, { "title": "Binder原理", "url": "/posts/Binder%E5%8E%9F%E7%90%86/", "categories": "Android", "tags": "Android", "date": "2021-01-05 14:00:00 +0800", "snippet": "Binder定义 机制、模型角度: Binder是一种Android中实现跨进程通讯（IPC）的方式，即Binder模型 结构、组成角度: Binder是一种虚拟的物理设备驱动，即Binder驱动 Android实现角度: Binder是一个类，实现了IBinder接口，即Binder类Binder 跨进程通信机制、模型Binder 跨进程通信机制模型基于CS模式ServiceManager进程：管理Service注册与查询，将字符形式的Binder名字转化成Client中对该Binder的应用Binder驱动: 通过内存映射传递进程间的数据 实现线程控制：采用Binder的线..." }, { "title": "适配器模式", "url": "/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/", "categories": "设计模式", "tags": "Adapter Pattern", "date": "2020-11-22 22:33:00 +0800", "snippet": "定义将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。特点优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器..." }, { "title": "Java中的synchronized修饰符", "url": "/posts/Java%E4%B8%AD%E7%9A%84synchronized%E4%BF%AE%E9%A5%B0%E7%AC%A6/", "categories": "Java", "tags": "Java基础", "date": "2020-10-23 23:46:00 +0800", "snippet": "基础Synchronized的作用主要有三个： 确保线程互斥的访问同步代码 保证共享变量的修改能够及时可见 有效解决重排序问题用法修饰普通方法锁的是实例对象，进入同步方法前要获得实例对象的锁。同步范围为synchronized修饰的方法，其他线程可以同时访问该实例对象的非synchronized修饰方法public class Test{ public synchronized void method_f(){ //do some thing; } public synchronized void method_s(){ //do so..." }, { "title": "欧几里得算法", "url": "/posts/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/", "categories": "算法", "tags": "最大公约数", "date": "2020-10-22 17:11:00 +0800", "snippet": "欧几里得算法（辗转相除法）设gcd(a,b)是计算自然数a和b的最大公约数的函数，a除b得到的商和余数分别为p和q，因为a=b×p+q，所以gcd(b,q)既整除a又整除b，也就是整除gcd(a,b)。反之，因为q=a-b×p，同理可证gcd(a,b)整除gcd(b,q)。因此可以知道gcd(a,b)=gcd(b,a%b)。不断这样操作下去，由于gcd的第二个参数总是不断减小的，最终会得到gcd(a,b)=gcd(c,0)。0和c的最大公约数是c，这样便计算出了a，b的最大公约数为c。int gcd(int a, int b){ if(b == 0) return a; return ..." }, { "title": "素数检测", "url": "/posts/%E7%B4%A0%E6%95%B0%E6%A3%80%E6%B5%8B/", "categories": "算法", "tags": "素数", "date": "2020-10-22 17:03:00 +0800", "snippet": " 素数是指恰好有两个约数的整数（1和其本身）。简单素性测试因为n的约数都不超过n，所以只需检查2~n-1的所偶整数是否整除n就能判定n是否为素数。进而，如果d是n的约数，那么n/d也是n的约数。由n=d×n/d可知min(d,n/d)≤sqrt(n)，所以只要检查 2~sqrt(n) 得到所有整数就可以了。由此可知，整数分解和约数枚举都可以在 O(sqrt(n)) 时间内完成。埃氏筛法要枚举n以内的素数，可以用埃氏筛法。 首先，将2到n范围内的所有整数写下来。 其中最小的数字2是素数。将表中所有2的倍数都划去， 表中剩余的最小数字是3，他不能被更小..." }, { "title": "快速幂运算", "url": "/posts/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97/", "categories": "算法", "tags": "幂运算", "date": "2020-10-22 16:55:00 +0800", "snippet": "普通的幂运算是将底数乘以底数指数次，需要O(n)的时间复杂度。通过将a的n次幂不断转换为a2的n/2次幂，可以将时间复杂度缩减至O(logn)typedef long long ll;int fastpow(int base, int exp){ int sum = 1; while(exp &amp;gt; 0){ if((exp &amp;amp; 1))//如果指数为奇数，将结果乘以底数 sum *= base; exp = exp &amp;gt;&amp;gt; 1;//指数除以2 base *= base;//底数平方 } return sum;" }, { "title": "Java类加载", "url": "/posts/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/", "categories": "Java", "tags": "JVM", "date": "2020-10-21 16:10:00 +0800", "snippet": "类加载过程虚拟机只加载程序执行时所需要的类文件。假设程序从MyProject.class开始运行，以下时虚拟机执行的步骤： 虚拟机有一个用于加载类文件的机制，例如，从磁盘上读取文件或者请求Web上的文件；它使用该机制来加载MyProject类文件中的内容。 如果MyProject类拥有类型为另一个类的域，或者是拥有超类，那么这些文件也会被加载。（加载某个类所依赖的所有类的过程称为类的解析) 接着，虚拟机执行MyProject中的main方法（它是静态的，无需创建类的实例）。 如果main方法或者main调用的方法要用到更多的类，那么接下来就会加载这些类。然而，类加载机制并非只使用..." }, { "title": "Java中的static修饰符", "url": "/posts/Java%E4%B8%AD%E7%9A%84static%E4%BF%AE%E9%A5%B0%E7%AC%A6/", "categories": "Java", "tags": "Java基础", "date": "2020-10-20 16:35:00 +0800", "snippet": "用法static变量使用形式：类名.静态变量 （该类的实例也可调用，推荐使用类名调用）ClassName.variable在类加载的时候完成初始化，内存中只有一份（存储在静态区），该类的所有实例共享这一个变量。static方法使用形式：方法名前+static修饰可以使用类名直接调用，不必在对象中调用。静态方法中不可直接调用非静态方法。static内部类static 可以用于修饰内部类，经static修饰的内部类可以不新建内部类实例而直接通过外部类访问。static代码块static代码块可以放在类中的任意位置（除了方法内部），块中的代码会在类加载的时候按照代码块的顺序执行，并且只会执行一..." }, { "title": "快速计算二进制数中1的个数", "url": "/posts/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/", "categories": "算法", "tags": "二进制", "date": "2020-10-18 14:08:00 +0800", "snippet": "int count1inBin(int binary){ int count = 0; while(binary&amp;gt;0){ binary &amp;amp;= (binary-1); ++count; } return count;}核心在于binary &amp;amp;= (binary-1);假设binary=X1 X2 …… Xn-1 Xn，其中 Xi(1≤i≤n)为1或0不妨设Xi是最右边的1，那么binary就可以写成如下的形式 binary=X1 X2……Xi-1 Xi 0……0，其中(1≤i≤n)，Xi 后面有n-i个0 因为 X..." }, { "title": "动态规划概述", "url": "/posts/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A6%82%E8%BF%B0/", "categories": "算法", "tags": "动态规划", "date": "2020-10-18 13:55:00 +0800", "snippet": "动态规划（Dynamic Programming） 将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。如何判断一个问题能否使用DP解决呢？能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。即是确定 DP状态最优子结构：将原有问题化分为一个个子问题，即为子结构。而对于每一个子问题，其最优值均由「更小规模的子问题的最优值」推导而来，即为最优子结构。因此「DP 状态」设置之前，需要将原有问题划分为一个个子问题，且需要确保子问题的最优值由「更小规模子问题的最优值」推出，此时子问题的最优值即为「DP 状态」的定义。无后效性：一旦f(n)确定，“我们如何凑出f(n)”就再..." }, { "title": "摩尔投票法", "url": "/posts/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95/", "categories": "算法", "tags": "摩尔投票法", "date": "2020-10-18 12:36:00 +0800", "snippet": "Moore majority vote 算法摩尔投票法基于这样一个事实： 当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。我们采用一个虚拟数组（在实现中可以使用两个变量代替，一个代表当前数组内元素的个数，另一个储存当前的候选数）来储存候选的众数。当遇到相同的数的时候向虚拟数组中加入当前的候选数，遇到不同的数的时候从虚拟数组中删除一个候选数。如果虚拟数组大小为0，向虚拟数组中加入当前位置的数作为候选数。遍历完成后数组中剩余的元素就是众数。因为众数大于数组的一半，哪怕最极端的其它数全都相同，众数也能在数组中剩余不少于2m-n（其中m为众数的数量，n为..." }, { "title": "StringBuilder和StringBuffer", "url": "/posts/StringBuilder%E5%92%8CStringBuffer/", "categories": "Java", "tags": "StringBuilder和StringBuffer", "date": "2020-10-17 14:47:00 +0800", "snippet": "层次结构StringBufferStringBuilderStringBufferStringBuffer 是一个线程安全类，它对append（）方法做了synchronized处理。在AbstractStringBuilder中：public AbstractStringBuilder append(String str){ if(str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0,..." }, { "title": "排序算法", "url": "/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/", "categories": "算法", "tags": "排序算法", "date": "2020-10-15 00:00:00 +0800", "snippet": "常用排序算法比较 排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 复杂性 插入排序 O(n2) O(n2) O(n) O(1) 稳定 简单 希尔排序 O(n1.3)     O(1) 不稳定 较复杂 冒泡排序 O(n2) O(n2) O(n) ..." } ]
