<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="排序算法" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="常用排序算法比较" /><meta property="og:description" content="常用排序算法比较" /><link rel="canonical" href="https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><meta property="og:url" content="https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" /><meta property="og:site_name" content="StarlightC" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-15T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="排序算法" /><meta name="twitter:site" content="@username" /><meta name="google-site-verification" content="blog.starlightc-cn.com" /> <script type="application/ld+json"> {"description":"常用排序算法比较","headline":"排序算法","url":"https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","@type":"BlogPosting","dateModified":"2020-10-15T00:00:00+08:00","datePublished":"2020-10-15T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},"@context":"https://schema.org"}</script><title>排序算法 | StarlightC</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="StarlightC"><meta name="application-name" content="StarlightC"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-180755436-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-180755436-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/sample/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">StarlightC</a></div><div class="site-subtitle font-italic">不积跬步，无以至千里</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/username" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mail.starlightc','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>排序算法</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>排序算法</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> starlightc </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 15, 2020, 12:00 AM +0800" prep="on" > Oct 15, 2020 <i class="unloaded">2020-10-15T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5081 words">28 min</span></div></div><div class="post-content"><h1 id="常用排序算法比较">常用排序算法比较</h1><div class="table-wrapper"><table><thead><tr><th style="text-align: center">排序方法<th style="text-align: center">平均时间复杂度<th style="text-align: center">最坏时间复杂度<th style="text-align: center">最好时间复杂度<th style="text-align: center">空间复杂度<th style="text-align: center">稳定性<th style="text-align: center">复杂性<tbody><tr><td style="text-align: center">插入排序<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n)<td style="text-align: center">O(1)<td style="text-align: center">稳定<td style="text-align: center">简单<tr><td style="text-align: center">希尔排序<td style="text-align: center">O(n<sup>1.3</sup>)<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">O(1)<td style="text-align: center">不稳定<td style="text-align: center">较复杂<tr><td style="text-align: center">冒泡排序<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n)<td style="text-align: center">O(1)<td style="text-align: center">稳定<td style="text-align: center">简单<tr><td style="text-align: center">快速排序<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(log<sub>2</sub>n)<td style="text-align: center">不稳定<td style="text-align: center">较复杂<tr><td style="text-align: center">选择排序<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(n<sup>2</sup>)<td style="text-align: center">O(1)<td style="text-align: center">不稳定<td style="text-align: center">简单<tr><td style="text-align: center">堆排序<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(1)<td style="text-align: center">不稳定<td style="text-align: center">较复杂<tr><td style="text-align: center">归并排序<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(nlog<sub>2</sub>n)<td style="text-align: center">O(n)<td style="text-align: center">稳定<td style="text-align: center">较复杂<tr><td style="text-align: center">基数排序<td style="text-align: center">O(d(n+r))<td style="text-align: center">O(d(n+r))<td style="text-align: center">O(d(n+r))<td style="text-align: center">O(r)<td style="text-align: center">稳定<td style="text-align: center">较复杂</table></div><p><br /><br /><br /><br /></p><h1 id="堆排序">堆排序</h1><p>堆排序（Heapsort）是利用<strong>堆</strong>这种数据结构所设计的一种排序算法</p><p><strong>基本步骤：</strong></p><ol><li><p>首先将数组构建成一个小顶堆（或大顶堆）</p><li><p>从堆顶nums[0]取出最小值（或最大值）放到数组后端nums[n]处，然后将nums[0]重新调整为小顶堆（或大顶堆）,再将nums[0]与nums[n-1]….</p><li><p>重复步骤2，直到整个数组都有序（堆的大小为1时）。</p></ol><h2 id="时间复杂度">时间复杂度</h2><p><strong>O(nlog<sub>2</sub>n)</strong></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">//调整函数</span>
<span class="kt">void</span> <span class="nf">mHeap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">start</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">])</span><span class="c1">//将标志位设置为左右子节点中最大（小）的</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="p">{</span><span class="c1">//当节点大于左右子节点的值时停止</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">//将数组构建成为一个大顶堆</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="c1">//从倒数第二层开始，到根节点为止</span>
		<span class="n">mHeap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//不断将堆顶元素移至堆底，并将堆的大小-1，当堆的大小为1时，排序完成</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">mHeap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="快速排序">快速排序</h1><p>快速排序是<strong>分而治之</strong>思想在算法上的典型应用，快速排序使用分治法策略把一个串行（list）分为两个子串行（sub-list）。</p><p><strong>基本步骤：</strong></p><ol><li><p>将第i个元素作为<strong>基准（pivot）</strong></p><li><p>重新排序数列，所有元素比基准值小的放在基准前面，所有比基准值大的放在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</p><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="动态图片演示" title="快速排序" /></p><h2 id="时间复杂度-1">时间复杂度</h2><p><strong>最好情况O(nlog<sub>2</sub>n)：</strong></p><p>Partition 每次恰好能均分序列，其递归树的深度就为.log2n.+1（.x.表示不大于x的最大整数），即仅需递归log2n次</p><p><strong>最坏情况O(n<sup>2</sup>):</strong></p><p>每次划分只能将序列分为一个元素与其他元素两部分，这时的快速排序退化为冒泡排序 (如待排序数组已经有序)</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">quicksort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//Partition Begin</span>
	<span class="kt">int</span>  <span class="n">pivot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	
	<span class="n">pivot</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">)</span><span class="c1">//此处须使用&gt;=（如果使用&gt;可能在两侧都等于pivot时产生死循环）</span>
			<span class="o">--</span><span class="n">j</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
    <span class="c1">//Partition End</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="c1">//递归在左右子分区调用</span>
		<span class="n">quicksort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span>
		<span class="n">quicksort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="归并排序">归并排序</h1><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p><br /><br /></p><p><strong>归并排序的实现分为两种：</strong></p><ul><li><strong>自上而下的递归</strong> （所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）<li><strong>自下而上的迭代</strong></ul><p><br /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="动态图片演示" title="归并排序" /></p><p><strong>算法步骤：</strong></p><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置</p><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p><li><p>重复步骤3，直到某一指针达到序列尾</p><li><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></ol><p><br /></p><h2 id="时间复杂度-2">时间复杂度</h2><p><strong>O(nlog<sub>2</sub>n)</strong></p><p><br /></p><h2 id="由上至下的递归">由上至下的递归</h2><p><strong>示例：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.starlightc-cn.com/assets/img/resource/uptodownmerge.jpg" alt="自上而下归并示例" /></p><p>通过”从上往下的归并排序”来对数组{80,30,60,40,20,10,50,70}进行排序时：</p><ol><li>将数组{80,30,60,40,20,10,50,70}看作由两个有序的子数组{80,30,60,40}和{20,10,50,70}组成。对两个有序子树组进行排序即可。<li>将子数组{80,30,60,40}看作由两个有序的子数组{80,30}和{60,40}组成。 将子数组{20,10,50,70}看作由两个有序的子数组{20,10}和{50,70}组成。<li>将子数组{80,30}看作由两个有序的子数组{80}和{30}组成。 将子数组{60,40}看作由两个有序的子数组{60}和{40}组成。 将子数组{20,10}看作由两个有序的子数组{20}和{10}组成。 将子数组{50,70}看作由两个有序的子数组{50}和{70}组成。</ol><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span><span class="c1">//当数列为空或者切分为单个元素的数列时，终止切分</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span><span class="c1">//递归切分</span>
	<span class="n">mergeSort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span><span class="n">z</span>
	<span class="n">merge</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="c1">//依次将两个有序数列中较小的数加入到临时向量中</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span>
		<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="c1">//将排序后的数列从临时向量中转移回去</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><h2 id="由下至上的迭代">由下至上的迭代</h2><p><strong>示例：</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://blog.starlightc-cn.com/assets/img/resource/downtoupmerge.jpg" alt="自下而上归并示例" /></p><p>通过”从下往上的归并排序”来对数组{80,30,60,40,20,10,50,70}进行排序时：</p><ol><li>将数组{80,30,60,40,20,10,50,70}看作由8个有序的子数组{80},{30},{60},{40},{20},{10},{50}和{70}组成。<li>将这8个有序的子数列两两合并。得到4个有序的子树列{30,80},{40,60},{10,20}和{50,70}。<li>将这4个有序的子数列两两合并。得到2个有序的子树列{30,40,60,80}和{10,20,50,70}。<li>将这2个有序的子数列两两合并。得到1个有序的子树列{10,20,30,40,50,60,70,80}。</ol><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">merge</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="c1">//依次将两个有序数列中较小的数加入到临时向量中</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span>
		<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">temp</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="c1">//将排序后的数列从临时向量中转移回去</span>
		<span class="n">nums</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*对数组a做若干次合并：数组a的总长度为len，将它分为若干个长度为gap的子数组；
 *             将"每2个相邻的子数组" 进行合并排序。
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     len -- 数组的长度
 *     gap -- 子数组的长度
 */</span>
<span class="kt">void</span> <span class="nf">mergeGroups</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="c1">// 将"每2个相邻的子数组" 进行合并排序。</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">gap</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">gap</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">gap</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">gap</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 若 i+gap-1 &lt; len-1，则剩余一个子数组没有配对。</span>
    <span class="c1">// 将该子数组合并到已排序的数组中。</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span><span class="o">+</span><span class="n">gap</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">gap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
 * 归并排序(从下往上)
 *
 * 参数说明：
 *     a -- 待排序的数组
 *     len -- 数组的长度
 */</span>
<span class="kt">void</span> <span class="nf">mergeSortDown2Up</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">||</span> <span class="n">len</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">n</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mergeGroups</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><strong>算法步骤：</strong></p><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="动态图片演示" title="冒泡排序" /></p><h2 id="时间复杂度-3">时间复杂度</h2><p><strong>最好情况O(n)：</strong></p><p>数组是正序时</p><p><strong>最坏情况O(n<sup>2</sup>):</strong></p><p>数组是反序时</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">n</span><span class="p">){</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
				<span class="n">swap</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="选择排序">选择排序</h1><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度</p><p><strong>算法步骤：</strong></p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<li>重复第二步，直到所有元素均排序完毕。</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="动态图片演示" title="选择排序" /></p><h2 id="时间复杂度-4">时间复杂度</h2><p><strong>O(n<sup>2</sup>)</strong></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//选择排序</span>
<span class="kt">void</span> <span class="nf">select_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>        <span class="c1">//有序区的末尾位置</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>        <span class="c1">//无序区的起始位置</span>
	<span class="kt">int</span> <span class="n">min</span><span class="p">;</span>      <span class="c1">//无序区中的最小元素位置</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		
		<span class="c1">//找出"arr[i+1] ... arr[n]"之间的最小元素的位置，并赋值给min</span>
		<span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
		
		<span class="c1">//交换arr[i]和arr[min]，交换之后保证了arr[0] ... arr[i]之间的元素是有序的</span>
		<span class="k">if</span><span class="p">(</span><span class="n">min</span> <span class="o">!=</span> <span class="n">i</span><span class="p">){</span>
				<span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="插入排序">插入排序</h1><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>算法步骤：</strong></p><ol><li>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt="动态图片演示" title="插入排序" /></p><h2 id="时间复杂度-5">时间复杂度</h2><p><strong>最坏情况O(n<sup>2</sup>):</strong></p><p>插入第2个元素时要考察前1个元素，插入第3个元素时，要考虑前2个元素，……，插入第N个元素，要考虑前 N - 1 个元素。因此，最坏情况下的比较次数是 1 + 2 + 3 + … + (N - 1)，等差数列求和，结果为 N<sup>2</sup> / 2</p><p><strong>最好情况O(n):</strong></p><p>数组已经是有序的，每插入一个元素，只需要考查前一个元素，因此最好情况下，插入排序的时间复杂度为O(n)</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处实现为从右至左，即i-1到0）</span>
			<span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
			<span class="n">j</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">array</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="希尔排序">希尔排序</h1><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是<strong>不稳定</strong>的。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</ul><p><strong>基本思想：</strong></p><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><br /></p><p><strong>算法步骤：</strong></p><ol><li><p>选择一个增量序列 g<sub>1</sub>，g<sub>2</sub>，……g<sub>i</sub> … g<sub>j</sub>……，g<sub>k</sub>，其中 g<sub>i</sub> &gt; g<sub>j</sub>, g<sub>k</sub> = 1； 按增量序列个数 k，对序列进行 k 趟排序</p><li><p>每趟排序，根据对应的增量 gi，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。当增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></ol><p><br /></p><h2 id="时间复杂度-6">时间复杂度</h2><p><strong>最好情况O(nsub&gt;1.3&lt;/sub&gt;)：</strong></p><p>采用<strong>Hibbard增量序列</strong>时</p><p><br /></p><p>下方代码采用shell增量序列，时间复杂度会高于Hibbard序列</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png" alt="" /></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">gap</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span><span class="c1">//构建shell增量序列</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
		<span class="c1">//具体实现时采用跨组处理的方式，即先处理每组i+gap再处理i+gap+gap以此类推... </span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">gap</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">gap</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">n</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">j</span> <span class="o">-=</span> <span class="n">gap</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">n</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">gap</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">gap</span> <span class="o">=</span> <span class="n">gap</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="计数排序">计数排序</h1><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据<strong>必须是有确定范围的整数</strong>。计数排序不是比较排序，排序的速度快于任何比较排序算法</p><h2 id="时间复杂度-7">时间复杂度</h2><p>O(n+k)</p><p>n为数组的长度，k为数组中最大整数的值</p><p><strong>算法步骤：</strong></p><ol><li>找出待排序的数组中最大和最小的元素k<li>统计数组中每个值为i的元素出现的次数，存入数组C（大小为k+1）的第i项<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="动态图片演示" /></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">countingSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">getK</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bucket</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">bucket</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bucket</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">while</span><span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">arr</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">bucket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">getK</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">largest</span><span class="p">)</span>
			<span class="n">largest</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">largest</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="桶排序">桶排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>为了使桶排序更加高效，我们需要做到这两点：</p><ol><li><p>在额外空间充足的情况下，尽量增大桶的数量</p><li><p>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</p></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h2 id="时间复杂度-8">时间复杂度：</h2><p><strong>O(n + f(n/m))</strong></p><p>n为数组的长度，m为桶的数量,f()为对桶中元素进行排序的算法的时间复杂度公式。当n==m时，退化为计数排序</p><p><strong>空间复杂度为：</strong> max(n, m).</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">BUCKET_NUM</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">//定义桶的大小</span>

<span class="k">struct</span> <span class="nc">ListNode</span><span class="p">{</span><span class="c1">//定义链表节点</span>
        <span class="k">explicit</span> <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">:</span><span class="n">mData</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">mNext</span><span class="p">(</span><span class="nb">NULL</span><span class="p">){}</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">mNext</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mData</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="nf">insert</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span><span class="c1">//向链表按照插入排序方式插入新节点</span>
        <span class="n">ListNode</span> <span class="n">dummyNode</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pre</span><span class="p">,</span><span class="o">*</span><span class="n">curr</span><span class="p">;</span>
        <span class="n">dummyNode</span><span class="p">.</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummyNode</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">mData</span><span class="o">&lt;=</span><span class="n">val</span><span class="p">){</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">mNext</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">pre</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">dummyNode</span><span class="p">.</span><span class="n">mNext</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">ListNode</span><span class="o">*</span> <span class="nf">Merge</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head1</span><span class="p">,</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head2</span><span class="p">){</span><span class="c1">//归并两个链表</span>
        <span class="n">ListNode</span> <span class="n">dummyNode</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">dummy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummyNode</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">head1</span> <span class="o">&amp;&amp;</span> <span class="nb">NULL</span><span class="o">!=</span><span class="n">head2</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">mData</span> <span class="o">&lt;=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">mData</span><span class="p">){</span>
                        <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
                        <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">mNext</span><span class="p">;</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                        <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
                        <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">mNext</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">dummy</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">mNext</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">head1</span><span class="p">)</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span><span class="o">!=</span><span class="n">head2</span><span class="p">)</span> <span class="n">dummy</span><span class="o">-&gt;</span><span class="n">mNext</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
       
        <span class="k">return</span> <span class="n">dummyNode</span><span class="p">.</span><span class="n">mNext</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">BucketSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[]){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">buckets</span><span class="p">(</span><span class="n">BUCKET_NUM</span><span class="p">,(</span><span class="n">ListNode</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">));</span><span class="c1">//创建桶</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
                <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">BUCKET_NUM</span><span class="p">;</span><span class="c1">//从数组映射到桶</span>
                <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
                <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">BUCKET_NUM</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="c1">//依次合并所有桶</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">Merge</span><span class="p">(</span><span class="n">head</span><span class="p">,</span><span class="n">buckets</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="c1">//将链表中的数据覆写到数组中</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">mData</span><span class="p">;</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">mNext</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /><br /><br /><br /></p><h1 id="基数排序">基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列.</p><blockquote><p>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="动态图片演示" /></p><h2 id="时间复杂度-9">时间复杂度</h2><p>O(d*(n+b))：</p><p>d为数组中数字位数的最大值，其中b是数字的进制数</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">maxbit</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//辅助函数，求数据的最大位数</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxData</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>              <span class="c1">///&lt; 最大数</span>
    <span class="c1">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">maxData</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">maxData</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//最大数的位数</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">maxData</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//p *= 10; 会有溢出的风险，所以采用降低maxData的数位</span>
        <span class="n">maxData</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="o">++</span><span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">radixsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//基数排序</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">maxbit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//计数器</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">radix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//进行d次排序</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//每次分配前清空计数器</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">radix</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//统计每个桶中的记录数</span>
            <span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">//将tmp中的位置依次分配给每个桶</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="c1">//将所有桶中记录依次收集到tmp中</span>
        <span class="p">{</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">radix</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//将临时数组的内容复制到data中</span>
            <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">radix</span> <span class="o">=</span> <span class="n">radix</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="p">[]</span><span class="n">tmp</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AE%97%E6%B3%95/'>算法</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-tag no-text-decoration" >排序算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=排序算法 - StarlightC&url=https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=排序算法 - StarlightC&u=https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=排序算法 - StarlightC&url=https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E9%87%8D%E6%9E%84/">重构简述</a><li><a href="/posts/Android-Studio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">Android Studio插件开发记录</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a> <a class="post-tag" href="/tags/adapter-pattern/">Adapter Pattern</a> <a class="post-tag" href="/tags/android-studio/">Android Studio</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/intellij-idea/">Intellij Idea</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/refactoring/">Refactoring</a> <a class="post-tag" href="/tags/stringbuilder%E5%92%8Cstringbuffer/">StringBuilder和StringBuffer</a> <a class="post-tag" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%BF%90%E7%AE%97/"><div class="card-body"> <span class="timeago small" > Oct 22, 2020 <i class="unloaded">2020-10-22T16:55:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>快速幂运算</h3><div class="text-muted small"><p> 普通的幂运算是将底数乘以底数指数次，需要O(n)的时间复杂度。 通过将a的n次幂不断转换为a2的n/2次幂，可以将时间复杂度缩减至O(logn) {% raw %} 1 2 3 4 5 6 7 8 9 10 11 typedef long long ll; int fastpow(int base, int exp){ int sum = 1; while(exp &gt; 0){...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%B4%A0%E6%95%B0%E6%A3%80%E6%B5%8B/"><div class="card-body"> <span class="timeago small" > Oct 22, 2020 <i class="unloaded">2020-10-22T17:03:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>素数检测</h3><div class="text-muted small"><p> 素数是指恰好有两个约数的整数（1和其本身）。 简单素性测试 因为n的约数都不超过n，所以只需检查2~n-1的所偶整数是否整除n就能判定n是否为素数。进而，如果d是n的约数，那么n/d也是n的约数。由n=d×n/d可知min(d,n/d)≤sqrt(n)，所以只要检查 2~sqrt(n) 得到所有整数就可以了。由此可知，整数分解和约数枚举都可以在 O(sqrt(n)) 时间内完成。...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"><div class="card-body"> <span class="timeago small" > Oct 22, 2020 <i class="unloaded">2020-10-22T17:11:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>欧几里得算法</h3><div class="text-muted small"><p> 欧几里得算法（辗转相除法） 设gcd(a,b)是计算自然数a和b的最大公约数的函数，a除b得到的商和余数分别为p和q，因为a=b×p+q，所以gcd(b,q)既整除a又整除b，也就是整除gcd(a,b)。反之，因为q=a-b×p，同理可证gcd(a,b)整除gcd(b,q)。因此可以知道gcd(a,b)=gcd(b,a%b)。不断这样操作下去，由于gcd的第二个参数总是不断减小的，最终会得...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="Older"><p>-</p></span> <a href="/posts/StringBuilder%E5%92%8CStringBuffer/" class="btn btn-outline-primary" prompt="Newer"><p>StringBuilder和StringBuffer</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//blog-starlihgtc-cn-com.disqus.com/embed.js', disqusConfig: function() { this.page.title = '排序算法'; this.page.url = 'https://blog.starlightc-cn.com/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/'; this.page.identifier = '/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/starlightchen">starlightc</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java%E5%9F%BA%E7%A1%80/">Java基础</a> <a class="post-tag" href="/tags/adapter-pattern/">Adapter Pattern</a> <a class="post-tag" href="/tags/android-studio/">Android Studio</a> <a class="post-tag" href="/tags/android/">Android</a> <a class="post-tag" href="/tags/intellij-idea/">Intellij Idea</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/refactoring/">Refactoring</a> <a class="post-tag" href="/tags/stringbuilder%E5%92%8Cstringbuffer/">StringBuilder和StringBuffer</a> <a class="post-tag" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a> <a class="post-tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://blog.starlightc-cn.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
